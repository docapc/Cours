%\listfiles
\documentclass[a4paper,12pt,twoside]{article}

%% packages
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,mathrsfs} 
%\usepackage{import}
\usepackage{float, subfig, caption}
\usepackage{libertine}
\usepackage{fancybox}
\usepackage{graphicx}
\usepackage{xcolor} %/ pour \Definecolor
\usepackage[pdftex,final=true]{hyperref}
%\usepackage[]{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=blue,
urlcolor=magenta, %/ file: adopte également cette couleur
filecolor=cyan, % ne fonctionne qu'avec run:, 
%citecolor=red
}
\urlstyle{same}
\usepackage[french]{minitoc}
\usepackage[acronym,toc,automake]{glossaries} % acronym pour les acronymes et toc pour inclusion des glossary dans la table des matières
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
%\usepackage{minted} % pour code avec coloration dans le texte
\usepackage{url} % Pour avoir de belles url
%% package ticks spécifiquement (pour les schémas) 
%\usepackage{tikz}%
%\usepackage[top=2cm,bottom=2cm]{geometry}
%% paramètres tikz
%\usetikzlibrary{patterns,decorations.pathreplacing,shapes.misc}
%\usetikzlibrary{calc}
%\tikzset{cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt},
%default radius will be 1pt. 
%cross/.default={5pt}}
% \definecolor{Gray}{gray}{0.9}
% \definecolor{LightCyan}{rgb}{0.88,1,1}
% \newcommand{\RN}[1]{\textup{\uppercase\expandafter{\romannumeral#1}}}    

%% Macros comme variable
%\newcommand{\editorpath}{C:/Program Files/Notepad++/notepad++.exe}
\newcommand{\exemplepath}{../Exercices}
\newcommand{\urlcolor}{magenta}  % couleur des liens https
\newcommand{\filecolor}{cyan} % couleur des liens file: file
\newcommand{\pdfcolor}{red} % couleur des liens file: .pdf
\newcommand{\foldercolor}{orange} % couleur des liens file: Folder
\newcommand{\cscolor}{green!60!black} % couleur des liens file: .cs
\newcommand{\slncolor}{violet} % couleur des liens file: .sln
\newcommand{\keycolor}{purple} % couleur des liens  de type mot clefs
%% Macros commun
\newcommand{\incode}[1]{{\footnotesize\ttfamily #1}} % pour du pseudo-code simple
\newcommand{\rem}[2]{\noindent\underline{Remarque} : \textit{#1}.\\ \indent #2}
\newcommand{\note}[1]{\noindent\underline{Note} : \\ \indent #1}
\newcommand{\defi}[2]{\noindent\underline{Définition} : \textbf{#1}.\\ \indent #2}
\newcommand{\slide}[2]{\textbullet ~ Slide n°#1 : \indent #2}
%% Macro spécifiques à ce fichier (pas forcément) : pour fonctionner il faut que le fichier ai été ouvert diretcement dans le dossier du .tex ...
\newcommand{\fileref}[2]{\hypersetup{urlcolor=\filecolor}\href{file: #1}{#2}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\pdfref}[2]{\hypersetup{urlcolor=\pdfcolor}\href{file: #1.pdf}{#2.pdf}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\csref}[2]{\hypersetup{urlcolor=\cscolor}\href{file:\exemplepath /#1.cs}{#2.cs}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\slnref}[2]{\hypersetup{urlcolor=\slncolor}\href{file:\exemplepath /#1.sln}{#2.sln}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\folderref}[2]{\hypersetup{urlcolor=\foldercolor}\href{file:\exemplepath /#1/.}{#2}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\keyref}[2]{\hypersetup{urlcolor=\keycolor} \href{#1}{\textbf{#2}}\hypersetup{urlcolor=\urlcolor}}
\newcommand{\keyword}[3]{\noindent\underline{Mot clef} : \keyref{#1}{#2}. \\ \indent #3}
%% Macro spécifiques à ce fichier (pas forcément)
\newcommand{\dpat}[7]{
\noindent \underline{Pattern} : \textbf{#1}, \indent (type : \textit{#2}) \\
\underline{Description} : \indent #3 \\
\underline{Exemple} : \indent #4 \\
\noindent \underline{Avantages} : 
\begin{itemize}
 #5
\end{itemize}
\noindent \underline{Inconvénients} : 
\begin{itemize}
 #6 
\end{itemize}
\underline{Liens} : #7 
}

%% Infos document
% Titre
\title{Notes sur le module : \textit{WPF.}}
% auteur
\author{Armel Pitelet}
% date de création du document
\date{\today}

%% Glossaire, acronymes et index
\makeglossaries

%% Glossaire et acronyme (déclarations)

% DIP : exemple de formalisme
\newglossaryentry{gl-dip}{
name = {DSP},
description = {la description détaillé}
}
\newglossaryentry{ac-dip}{
type = \acronymtype, name = {DSP}, 
description = {Nom simple}, 
first = {Première occurence\glsadd{gl-dip}}, 
see = [Glossaire:]{gl-dip}
}


\begin{document}
%% Organisation globale 
\maketitle
\tableofcontents

%%--------------------------------------------------------------------------------------------------------------------------------
\section{Bases}

\keyword{WPF}{https://fr.wikipedia.org/wiki/Windows\_Presentation\_Foundation}{Permet de créer des application en mode fenêtre.Pour utiliser WPF, soit on passe par du .Net Framework (ancienne version) soit on passe sur du .Net Core (nouvelle).}\\

\rem{XAML}{Language balise associé au WPF. C'est via XAML que l'on définit le design. Voir les différents layout ci dessous}\\

\rem{Stack Panel}{Layout qui permet de stacker plusieurs éléments les uns à la suite des autres.}\\

\rem{Wrap panel}{Identique au stack panel mais passe à la ligne suivante lorsque la ligne en cours est pleine (dynamiquement en fonction de la taille de l'écran contrairement au stack panel).}\\

\rem{Dock panel}{Permet de fixer un élément à un endroit donné avec une taille donnée.}\\

\rem{Grid}{Permet de créer des lignes et des colonnes avec des tailles possiblement relative les unes aux autres.}\\

\rem{Canvas}{Permet un placement libre des éléments.}\\

\note{Pour une intro à wpf : \url{https://wpf-tutorial.com/}.}\\

\rem{Textbox}{Permet de créer une boite de texte éditatble.}\\

\rem{Textblock}{Même chose que textblox mais le texte n'est pas éditable.}\\

\rem{Combobox}{Permet de faire une liste déroulante à possibilité de choix fixes.}\\

\rem{Listbox}{Même chose que combobox mais sous forme de liste et pas d'un menu déroulant.}\\

\rem{Menu}{Permet de faire des menus, avec potentiellement des sous menu inclus.}\\

\note{Attention par défaut les images ne sont pas embarquées dans l'application WPF. On les voits dans le designer mais pas dans l'application une fois celle ci lancée. Il faut changer le statut de l'image en ``ressource de l'application'' (dans les paramètres Propriétés/Avancé). Cela permet d'embarquer l'image avec le dll. On peut aussi la mettre en ``Contenue''. A ce moment l'image sera copiée (à la compilation) avec la même arborescence que l'application lors de la création.}\\

\note{Pour faire des gitignore facilement \url{https://www.toptal.com/developers/gitignore}}\\

\note{Pour de la génération de classe automatique \url{https://github.com/AutoFixture} et \url{https://github.com/bchavez/Bogus}.}\\


\rem{Utiliser les ToString}{Mauvaise pratique pour faire de l'affichage en WPF}\\

\section{Event et Binding}

\rem{Sur les events}{Les events sont en fait des implémentation du pattern observateur qui permettent de déclencher les évènement sur un changement d'état. POur ce sur quoi c'est basé Nico pour son cour voir : \url{https://docs.microsoft.com/fr-fr/dotnet/standard/events/}.}\\

\rem{Sur le remplacant de WCF}{Il s'agit de gRPC : google remote protocole col (service gRPC ASP.Net Core). S'appuie sur http 2 (sérialisation binaire). Très proche sur du wcf (basé sur SOAP : sérialisation xml) mais avec de bien meilleur performance.}\\

\rem{Sur le binding}{Il est possible d'utiliser le Binding pour relier n'importe quel élément. Attention on ne bind que les propriétés, pas les attributs.}\\

\rem{DataContext}{Définit la source des bindings. (peut etre un objet fenêtre ou un objet de type manager, ou autre...).}\\

\rem{ObservableCollection}{Permet de définir des collections observables : permet de s'abonner par la suite pour suivre les changements.}\\

\rem{Sur IList et IEnumerable}{Si l'on veut faire la modif autant passer par le IList mais si l'on veut just eliste autant avoir un IEnumerable pour garder la généricité la plus haute possible.}\\

\rem{Sur le mapping}{Il ne fuat pas faire trop de profile de mapping, mais les grouper par grand groupes d'objets (et pas par objets).}\\

\rem{Sur la notion de Model}{ Un ObjectModel (dédié à la vue) sert pour l'affichage : c'est encore différent d'un Dto(transfert sérialisation), d'une Entity (classe de bdd) ou d'un objet métier. Il peut contenir de la validation de données supplémentaire.}\\

\rem{Sur les Entity}{Les Entities peuvent contenir des méthodes.}\\

\rem{Element Name}{après un binding = qqchose (comme SelectedItem), ElementName$=$UnAutre élément () permet de binder à autre chose que le context courant (sur un autre élément graphique). On peut également changer le \incode{mode} de binding (voir one way, two way, ...). \incode{UpdateSourceTrigger} permet de changer l'élément déclencheur (PropertyChanged,...)}\\

\rem{Pour les changement sur les property soient appliqué sans passer par un SelectedItem}{On peut utiliser INotifyPropertyChanged dans nos modèles. Cela impose de définir un évènement handler PropertyChangedEventHandler. L'implémentation de la méthode associée impose de changer les propriétés classiques en attribut + propriété set qui track le changement (voir le UserModel dans le code de nico.). En fait SelectedItem a en interne ces propriété qui font que les changement dessus sont suivis.}\\

\rem{L'annotation [CallerMemberName]}{devant un argument dans une méthode permet de récupérer le nom de la propriété qui appel cette méthode.}\\

\rem{ILSPie}{permet de récupérer du code décompiler à partir d'un .dll. Le fichier pdb permet de faire le lien entre le .dll et le code .cs}\\

\rem{Lors d'un Binding : Trois questions à se poser}{\begin{itemize}
\item 1 - Quel est le DataContext? Si il n'y en a pas on remonte à l'élément du dessus. (dans le xaml, jusqu'au niveau de la fenêtre.). Ici on a set le DataContext au niveau de la main window.
\item 2 - Quelle est la propriété source (itemsource ou à droite du binding), propriété cible (selecteditem ou à gauche du binding),
\item 3 - Quel mode de binding utilisé (dans un sens, dans l'autre, dans les deux sens, property Mode$=$... dans un binding).\\
\end{itemize}}

\rem{Exemple implicite du binding}{Le textBlock Text $=$ "\{Binding Name\}" est un binding implicite dans le context définies par itemsource}.\\

\rem{Pour un équivalent du apt get-install}{Voir ChocolaTey (présent dans node.js) pour un équivalent sous windows.}\\

\note{Voir Bogus pour un autre genre de AutoFixture.}\\

\rem{Sur les converter}{Il faut hériter de IValueConverter et décorer avec ValueConversion(source, destination). Il faut ensuite implémenter Convert (du modèle à la vue) et ConvertBack(de la vue vers le modèle). Dans les namespace (xlmns en début de fichier xaml), puis les ressources (Env Windows ressource) il faut ensuite inclure les converter. On peut ensuite utiliser le converter. Ces converters peuvent servir pour les images par exemple (convertion d'image) ou bien faire de la vérifiction de droit.}\\

\rem{Sur la vue}{On appel vue la partie xaml du wpf. Les donnéès provenant de la vue proviennent de la fenêtre. Voir la v2 du code de nico.}\\


\section{Sur lien wpf et api}

\rem{Si l'on oublie les chaines deconnection}{Il existe un site connection string qui répertorie tt les synatxes possiblent en fonction du type de bdd : \url{https://www.connectionstrings.com/}.}\\

\rem{Sur les migrations avec CLI}{\incode{dotnet ef migrations add InitialCreate $--$projet chemin\_vers\_le.csproj} pour initialiser la première migration (il faut lui indiquer le chemin du projet ou est le DbContext). On doit aussi pouvoir faire $--$ output projetcible.csproj pour déplacer la migration ailleur. Pour faire la migration il est nécessaire d'avoir un constructeur qui prend un DbContextOptions. }\\

\rem{Pour utiliser la chaine de connexion du appsettings.json pour la migration}{Parait compliqué. On peut au mieux lui passer la chaine via le programme de l'API).}\\

\rem{Sur l'update de la bdd}{Soit on passe par les ligne de commande (via update) ou bien le configurer dans le program.cs de l'api. (voir la partie \incode{app.Services.CreateScope()})}\\

\rem{Sur le \incode{using} en inline}{Inline \incode{using} (IDisposable) {des truc} permet de créer un scope locale dans lequel les \incode{trucs} seront détruit à la fin du scope. IDisposable est une interface qui implémente la méthode Dispose (qui permet de \textit{refermer} des ressources (les rendre inaccessible jusqua ce que le Garbage collector les désaloues)). Ex : un DbContext est un disposable et pourrait être utilisé de cette manière.}\\

\rem{Sur le Set du DbContext}{Lorsque l'on fait un Context.Set<Type> on crée une représentation de la bdd. Si l'on fait un Where dessus on récupère juste un IQueryable sur la représentation. La requête vers la bdd n'est faite qu'à partir du moment ou l'on fait un ToList() ou un AsEnumerable() dessus.}\\

\rem{Sur les retry de requête}{Il faut utiliser des bibliothèques externes comme Polly qui permet d'implémenter un retry avec condition et nombre d'essaie avec ou sans attente.}\\

\rem{Dans le cli}{on peut faire dans un terminal \incode{dotnet watch run} pour faire de la compilaytion automatique à chaque sauvegarde. Il faut être dans le dossier contenant le proejt (ou la solution $\to$ à tester.)}\\

\section{Sur les thèmes en wpf}

\rem{Pour styliser un peu les applications}{Il faut passer par des framework externe : \keyref{https://material.io/design}{matérial-design}, ou bien \keyref{https://mahapps.com/}{mahapps-metro}.}\\

\rem{Sur material design}{Il faut commencer par installer le themes via les Nugets (avec les dépendances indiquées sur le site). Puis dans l'app.xaml il faut compléter la partie ressource Dictionnary (dans application.Resources). Voir le site de material design (notemment la \keyref{https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit}{démo}) et l'exemple de nico.}\\

\rem{Une fois le style importé et configuré}{On a accès à des propriétés propres aux thèmes (notemment via le champ Style).}\\

\rem{Sur le changement de fenêtre de démarage}{En changeant startupUri dans le xaml de l'app, on peut changer la fenêtre de démrage.}\\

\rem{Sur l'élement visual state}{L'élement VisualState manager permet de déclarer des éléments changeant dans le temps. (en taille, couleurs, positions...).}\\

\note{Voir rating bar pour une nottation avec des étoiles animées!!!.}\\

\section{Sur les user control}

\rem{Pour lancer un build automatique}{On peut dans le CLI faire un \incode{dotnet watch run} dans le dossier du projet qui nous interesse.}\\

\rem{Sur le DataContext dans un UC}{Si il n'y a pas de DataContext dans le UC, alors le programme remonte les windows parents pour en trouver un.}\\

\rem{Sur le Binding spécifique dans un UC}{On peut nommer le UC dans le xaml (x:Name"LeNom") et dans le Binding on peut choisir l'élément à choisir via un ElementName.}\\

\note{Les classes sont partielles car déclarée dans le .xaml et dans le .cs. Sans le \incode{partial} la vue ne fonctionnerai tt simplement pas!}\\

\rem{Pour passer un objet d'une fenêtre à l'autre}{Il faut déja nommé le user control dans son appel (dans la fenêtre parent)}\\

\rem{Sur les dependancy property}{DependancyProperty permet d'enregistrer (via Register(nom de la prop, type de la propriété, type du propriétaire)) une propriété qui sait se notifier soit même.}\\

\note{TT les propriétés attaché de base à la vue sont des DependancyProperty (celle à gauche d'un binding).}\\

\note{On peut faire Binding . ou le point design this, la fenêtre en cours.}\\

\note{On peut s'éviter de faire de la dupplication sur le OnNotifyPropertyChange en définissant une classe de laquelle les autres UserControl dérivent (Au lieu de dériver directement de User control)}

\rem{Sur cette manière de faire les user controls}{Cela implique de pouvoir réutiliser des user control dans d'autres mais fait comme sa on réutilise et le code behind et le xaml associé.}\\

\rem{Pour faire autrement}{Il faut passer par un DataTemplate (que l'on doit nommer via x:key$=$) à l'intérieur des Ressources (UserControl.Resource ou Application.Ressource). Plus bas dans le xaml on peut ensuite déclarer un ContentControl avec l'attribut ContentTemplate = \{StaticRessource nomDuTemplate\} pour réutiliser cette partie de xaml.}\\

\note{Dans le template on peut également passer un DataType = \{x:type TypeName\} et le réutiliser dans un Datatemplate plus bas}

\note{Utiliser un DataTemplate permet de ne pas avoir à utiliser la logique, on ne partage que du xaml.}\\

\note{Pour qq exemple : \url{https://www.softfluent.fr/blog/les-datatemplate-wpf-partie-1/}.}\\

\section{La navigation}

Le navigateur permet de centraliser les vue navigables et de gérer les transitions entre chaque.\\
Il faut commencer par définir une interface pour le navigateur.\\

\rem{Sur l'utilisation}{On instancie un navigateur et on utilise sa méthode RegisterView pour enregistrer les vue utilisable par le navigateur.}\\

\note{En WPF les Control sont tt ce qui est objet visuel (usercontrol, bouton, fenêtre).}\\

\rem{Sur lélément stack}{On passe par ce type de collection pour faciliter la navigation. Le stack est un Last In, Firt Out.}\\

\rem{Dans la main window}{On utilise le Navigator dans la main windows pour définir la première page via un Navigateto(typeof(MaPag)).}\\

\note{Il existe des frameworks (MVVM) qui implémentent nativement ce genre de navigateur.}\\

\section{Les bibliothèques de controles personnalisés WPF}

C'est un type de projet que l'on peut créer lors de l'ouverture d'un nouveau projet WPF.\\
Permet de faire des composant partageable entre différentes applications.\\
Cela permet cette fois ci de partager une logique commune entre différent projet (ou bien component).\\

\note{Dans le folder theme on a une dicitonnaire de ressource qui permet de définir les styles associées aux composants.}\\

\rem{Sur l'importation}{Il faut ensuite importer ce dictionnaire de ressource dans celui de l'application qui veut utiliser la ressource.}\\



%%--------------------------------------------------------------------------------------------------------------------------------1
%% Glossaires


\end{document}
\end{document}
